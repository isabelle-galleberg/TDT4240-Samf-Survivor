package com.mygdx.tdt4240.states.PlayState.Model.ecs.NPCBehavior
import com.github.quillraven.fleks.World
import com.mygdx.tdt4240.states.PlayState.Model.ecs.entities.BombFactory
import com.mygdx.tdt4240.states.PlayState.Model.ecs.systems.NPCSystem
import com.mygdx.tdt4240.states.PlayState.Model.ecs.systems.TileSystem
import com.mygdx.tdt4240.states.PlayState.Model.ecs.types.DirectionType
import java.util.*
import kotlin.math.abs
import kotlin.random.Random

object NPCBehavior : Layer4() {

}
/* Set bombs with a random delay between 2 and 10 seconds*/
open class Layer4 : Layer3() {
    fun setBombs(world: World) {
        //TO DO: Stop this loop when game is over
        while(true){
            Timer().schedule(object : TimerTask() {
                override fun run() {
                    BombFactory.createBomb(world,NPCSystem.getPosition().first,NPCSystem.getPosition().second )
                }
            }, Random.nextLong(2000,10000))
        }
    }
}
/* Move away from bombs nearby*/
open class Layer3 : Layer2() {
    fun avoidBomb(bombPos: Pair<Int, Int> ) {
        var NPCPosition = NPCSystem.getPosition()
        if (bombPos.first == NPCPosition.first && abs(bombPos.second - NPCPosition.second) <= 3) {
            if (bombPos.second < NPCPosition.second) {
                changeDirection(randomDirection(DirectionType.UP))
            } else {
                changeDirection(randomDirection(DirectionType.DOWN))
            }
            avoidCollision()
        } else if (bombPos.second == NPCPosition.second && abs(bombPos.first - NPCPosition.first) <= 3) {
            if (bombPos.first < NPCPosition.first) {
                changeDirection(randomDirection(DirectionType.LEFT))
            } else {
                changeDirection(randomDirection(DirectionType.RIGHT))
            }
            avoidCollision()
        }

    }
}

/* Avoid collision with fire, walls and crates*/
open class Layer2 : Layer1() {
    fun avoidCollision() {
        var NPCDirection = NPCSystem.getDirection()
        var NPCPosition = NPCSystem.getPosition()
        var collision = true
        while (collision) {
            if (NPCDirection == DirectionType.DOWN) {
                if (NPCPosition.second == 8 || TileSystem.getPositions().contains(Pair(NPCPosition.first, NPCPosition.second + 1))) {
                    NPCDirection = randomDirection(DirectionType.DOWN)
                } else {
                    collision = false
                }
            } else if (NPCDirection == DirectionType.UP) {
                if (NPCPosition.second == 0 || TileSystem.getPositions().contains(Pair(NPCPosition.first, NPCPosition.second - 1))) {
                    NPCDirection = randomDirection(DirectionType.UP)
                } else {
                    collision = false
                }
            } else if (NPCDirection == DirectionType.LEFT) {
                if (NPCPosition.first == 0 || TileSystem.getPositions().contains(Pair(NPCPosition.first - 1, NPCPosition.second))) {
                    NPCDirection = randomDirection(DirectionType.LEFT)
                } else {
                    collision = false
                }
            } else {
                if (NPCPosition.first == 8 || TileSystem.getPositions().contains(Pair(NPCPosition.first + 1, NPCPosition.second))) {
                    NPCDirection = randomDirection(DirectionType.RIGHT)
                } else {
                    collision = false
                }
            }
        }
        changeDirection(NPCDirection)

    }
    /* Finds new random direction that is not the NotDirection*/
    fun randomDirection(NotDirection: DirectionType): DirectionType {
        var randomDirections = DirectionType.values().toList().shuffled()
        return if (randomDirections.first() == NotDirection)
            randomDirections.last()
        else {
            randomDirections.first()
        }
    }
}

/* Change direction*/
open class Layer1 {
    fun changeDirection(direction: DirectionType) {
        NPCSystem.setDirection(direction)
    }
}